# 计算机二级笔记 

# 目录
## [树](#tree)
## [算法](#algorithm)
## [栈](#stack)
## [队列](#queue)
## [数据库](#database)
## [计算机网络](#net)

## 树<a id="tree"></a>
树是n（n>=0）个结点的有限集        

1. 树中一个结点的孩子个数称为该结点的度,树中结点的最大度数称为树的度    .    
2. 度大于0的结点称为分支结点(又称非终端结点);度为0(没有子女结点)的结点称为叶子结点(又称终端结点)。在分支结点中,每个结点的分支数就是该结点的度。
3. - 结点的深度是从根结点开始自顶向下逐层累加的。
   - 结点的高度是从叶结点开始自底向上逐层累加的。
   - 树的高度(或深度)是树中结点的最大层数。
4. 有序树和无序树。树中结点的各子树从左到右是有次序的,不能互换,称该树为有序树,否则称为无序树
5. 路径和路径长度。树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的,而路径长度是路径上所经过的边的个数。
6. 森林。森林是m(m≥0)棵互不相交的树的集合。

    #### 树的性质
    1. 树中的结点数等于所有结点的度数加1.
    2. 度为m的树中第i层上最多有m<sup>i-1</sup>个节点(i>=1)。
    3. 高度为h的m叉树至多有(m<sup>h</sup>-1)/(m-1)个结点。
    4. 具有n个结点的m叉数的最小高度为[log<sub>m</sub><sup>(n(m-1)+1)</sup>]  


### 二叉树
#### 二叉数的遍历

**前序遍历**：根结点 ---> 左子树 ---> 右子树   
**中序遍历**：左子树 ---> 根结点 ---> 右子树    
**后序遍历**：左子树 ---> 右子树 ---> 根结点 
![二叉数遍历](./1.png)    
**前序遍历**：1  2  4  5  7  8  3  6    
**中序遍历**：4  2  7  5  8  1  3  6    
**后序遍历**：4  7  8  5  2  6  3  1
  
### 程序的执行方式
1. **顺序**执行
    - **可再现性**             
        处理机严格地按照程序所规定的顺序执行，即每一操作必须在下一个操作开始之前结束
    - **封闭性**         
        程序在封闭的环境下运行，即程序运行时独占全机资源，资源的状态（除初始状态外)只有本程序才能改变它，程序一旦开始执行，其执行结果不受外界因素影响
    - **可再现性**           
    指只要程序执行时的环境和初始条件相同，当程序重复执行时，不论它是从头到尾不停顿地执行，还是“停停走走”地执行，都可获得相同的结果程序顺序执行时的这种特性，为程序员检测和校正程序的错误带来了很大的方便
2. **并发**执行
    - **间断性**        
    程序在并发执行时，由于它们共享系统资源，以及为完成同一项任务而相互合作，致使在这些并发执行的程序之间形成了相互制约的关系。相互制约将导致并发程序具有“执行-暂停-执行”这种间断性的活动规律。
    - **失去封闭性**          
    当系统中存在着多个可以并发执行的程序时，系统中的各种资源将为它们所共享，而这些资源的状态也由这些程序来改变，致使其中任一程序运行时，其环境都必然受到其他程序的影响。
    - **不可再现性**           
    程序在并发执行时，由于失去了封闭性，其计算结果必将与并发程序的执行速度有关，从而使程序的执行失去了可再现性。换而言之，程序经过多次执行后，虽然它们执行时的环境和初始条件相同，但得到的结果却各不相同。
    
## <a id="algorithm">算法</a>
### 算法的复杂度
- 复杂度分析   
通常一个算法的复杂度是由其输入量决定的
- 时间复杂度      
执行算法所需要的计算工作量
- 空间复杂度     
算法在计算机内执行时所需存储空间的度量

## <a id="stack">栈</a>
只允许在一端进行插入或删除操作的线性表。首先，栈是一种线性表，但限定这种线性表只能在某一段进行插入和删除操作。

栈顶（**Top**）：线性表允许进行插入和删除的一端。

栈底（**Bottom**）：固定的，不允许进行插入和删除的另一端。

空栈：不含任何元素。   

![栈](./2.jfif)

栈空条件：S.top == -1

栈满条件：S.top == MAXSIZE - 1

栈长：S.top + 1

## <a id="queue">队列</a>
一种特殊的线性表,它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。


#### 结构化程序设计和结构化程序设计方法 
结构化程序设计适用于程序规模较大的情况，对于规模较小程序也可采用非结构化程序设计方法。       
1.  - 结构化程序设计是进行以**模块功能**和**处理过程**设计为主的详细设计的基本原则
    - 结构化程序设计方法是按照模块划分原则以提高程序**可读性**和**易维护性**、**可调性**和**可扩充性**为目标的一种程序设计方法
2. 原则
    - 自顶向下
    - 逐步细化
    - 模块化
    - 结构化编码
   
    
    
    
## <a id="database">数据库</a>

### 数据库管理技术发展的三个阶段
1. 人工管理阶段   
20世纪50十年代中期以前，计算机主要用于科学计算，由**人工**进行数据管理。
2. 文件系统管理阶段   
20世纪50年代后期到60年代中期，这时硬件方面有了磁盘、磁鼓等直接存取存储设备；软件方面，操作系统中已经有了专门的数据管理软件。一般称为文件系统，处理方式上不仅有批处理，而且能够联机实时处理。
3. 数据库系统阶段   
20世纪60年代，这时硬件已有大量容量磁盘，硬件价格下降，软件价格上升。处理文件方式上，人们越来越需要联机实时处理。在这种背景下就诞生了统一管理数据的专门软件系统——数据库管理系统。

### E-R图(实体-联系模型)
实体：客观存在且可以互相区别的事物。
属性：实体的特征描述。

### 数据库的三范式
1. 第一范式  
表中的每一列都不可再分
2. 第二范式  
表中的非主键列与的主键列相关
3. 第三范式  
表中的非主键列与主键列直接相关

## 计算机网络
### 基础概念


### HTTP状态码
:boom: :boom:响应分为五类：信息响应(100–199)，成功响应(200–299)，重定向(300–399)，客户端错误(400–499)和服务器错误 (500–599)

|分类|分类描述|
|:-:|:-:|
|1**|信息，服务器收到请求，需要请求者继续执行操作|
|2**|成功，操作被成功接收并处理|
|3**|重定向，需要进一步的操作以完成请求|
|4**|客户端错误，请求包含语法错误或无法完成请|
|5**|服务器错误，服务器在处理请求的过程中发生了错误|

#### 信息响应
|状态码|名称|描述|
|:-:|:-:|:-:|
|100|Continue|这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求|
|101|Switching Protocols|指明服务器即将切换的协议|
|102|Processing|服务器已收到并正在处理该请求，但当前没有响应可用|

#### 成功响应
|状态码|名称|描述|
|:-:|:-:|:-:|
|200|OK|请求成功|
|201|Created|该请求已成功，并因此创建了一个新的资源|
|202|Accepted|请求已经接收到，但还未响应，没有结果|
|203|Non-Authoritative Information|服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝|
|204|No Content|对于该请求没有的内容可发送，但头部字段可能有用|
|205|Reset Content|告诉用户代理重置发送此请求的文档|
|206|Partial Content|当从客户端发送Range范围标头以只请求资源的一部分时，将使用此响应代码|

#### 重定向消息
|状态码|名称|描述|
|:-:|:-:|:-:|
|300|Multiple Choice|请求拥有多个可能的响应|
|301|Moved Permanently|请求资源的 URL 已永久更改|
|302|Found|此响应代码表示所请求资源的 URI 已暂时更改|
|303|See Other|服务器发送此响应，以指示客户端通过一个`GET`请求在另一个`URI`中获取所请求的资源|
|304|Not Modified|用于缓存的目的。它告诉客户端响应还没有被修改，因此客户端可以继续使用相同的缓存版本的响应|
|307|Temporary Redirect|服务器发送此响应，以指示客户端使用在前一个请求中使用的相同方法在另一个`URI`上获取所请求的资源|


#### 客户端错误响应
|状态码|名称|描述|
|:-:|:-:|:-:|
|400|Bad Request|由于被认为是客户端错误（例如，错误的请求语法、无效的请求消息帧或欺骗性的请求路由），服务器无法或不会处理请求|
|401|Unauthorized|客户端必须对自身进行身份验证才能获得请求的响应|
|403|Forbidden|客户端没有访问内容的权限(与 401 Unauthorized 不同，服务器知道客户端的身份)|
|404|Not Found|服务器找不到请求的资源|
|405|Method Not Allowed|服务器知道请求方法，但目标资源不支持该方法|
|406|Not Acceptable|没有发现任何符合用户代理给定标准的内容|
|407|Proxy Authentication Required|类似于 401 Unauthorized 但是认证需要由代理完成|
|408|Request Timeout|此响应由一些服务器在空闲连接上发送，即使客户端之前没有任何请求|
|409|Conflict|请求与服务器的当前状态冲突|
|410|Gone|请求的内容已从服务器中永久删除且没有转发地址|
|411|Length Required|服务端拒绝该请求,因为没有`Content-Length`头部字段|
|412|Precondition Failed|客户端在其头文件中指出了服务器不满足的先决条件|
|413|Payload Too Large|请求实体大于服务器定义的限制|
|414|URI Too Long|客户端请求的`URI`比服务器愿意接收的长度长|
|415|Unsupported Media Type|服务器不支持请求数据的媒体格式|
|416|Range Not Satisfiable|该范围可能超出了目标`URI`数据的大小|
|417|Expectation Failed|此响应代码表示服务器无法满足`Expect`请求标头字段所指示的期望|


#### 服务端错误响应
|状态码|名称|描述|
|:-:|:-:|:-:|
|500|Internal Server Error|服务器遇到了不知道如何处理的情况|
|501|Not Implemented|服务器不支持请求方法，因此无法处理|
|502|Bad Gateway|服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应|
|503|Service Unavailable|服务器没有准备好处理请求|
|504|Gateway Timeout|服务器充当网关且无法及时获得响应|
|505|HTTP Version Not Supported|服务器不支持请求中使用的 HTTP 版本|